// Main Nextflow config file for nf-scrnaseq pipeline

// Global default params
params {
    // Input/Output
    input              = null           // Path to input data (10X folder, h5ad, or csv)
    input_format       = 'auto'         // 'auto', '10x', 'h5ad', 'csv'
    outdir             = './results'    // Output directory

    // QC thresholds
    min_genes          = 200            // Minimum genes per cell
    min_cells          = 3              // Minimum cells per gene
    max_genes          = 2500           // Maximum genes per cell
    max_counts         = null           // Maximum counts per cell (null = auto)
    max_pct_mt         = 5              // Maximum mitochondrial percentage

    // Gene filtering
    gene_type          = 'protein_coding' // Gene biotype to keep (null = all)
    exclude_mt         = false          // Exclude mitochondrial genes
    exclude_ribo       = false          // Exclude ribosomal genes

    // Doublet detection and decontamination
    run_doublet_detection = true        // Run doublet detection
    run_scrublet       = true           // Run Scrublet (Python)
    run_scdblfinder    = false          // Run scDblFinder (R) - slower
    run_decontx        = false          // Run DecontX (R) - slower
    scrublet_threshold = 'auto'         // Doublet threshold (auto or numeric)
    expected_doublet_rate = 0.06        // Expected doublet rate (typically 0.05-0.1)

    // Normalization
    target_sum         = 'auto'         // Target sum for normalization (auto = median)
    log_transform      = true           // Log-transform after normalization

    // Highly variable genes
    n_top_genes        = 2000           // Number of top HVGs to select (null = use thresholds)
    hvg_min_mean       = 0.0125         // Minimum mean expression
    hvg_max_mean       = 3              // Maximum mean expression
    hvg_min_disp       = 0.5            // Minimum dispersion
    hvg_flavor         = 'seurat'       // HVG selection flavor ('seurat' or 'cell_ranger')

    // Dimensionality reduction
    n_pcs              = 50             // Number of principal components
    n_neighbors        = 15             // Number of neighbors for UMAP/clustering
    run_umap           = true           // Compute UMAP embedding
    run_tsne           = false          // Compute t-SNE embedding (slower)
    umap_min_dist      = 0.5            // UMAP min_dist parameter
    tsne_perplexity    = 30             // t-SNE perplexity

    // Clustering
    run_leiden         = true           // Run Leiden clustering (recommended)
    run_louvain        = false          // Run Louvain clustering
    leiden_resolution  = 1.0            // Leiden resolution (higher = more clusters)
    louvain_resolution = 1.0            // Louvain resolution (higher = more clusters)
    cluster_key        = 'auto'         // Primary cluster key to use ('auto', 'leiden', 'louvain')

    // R-based clustering (requires manual R package installation)
    run_seurat_clustering = false       // Run Seurat SNN clustering (R-based)
    run_celda            = false        // Run Celda clustering (R-based)
    seurat_resolution    = 0.8          // Seurat clustering resolution
    celda_L              = 'auto'       // Number of cell modules for Celda (auto or integer)
    celda_K              = 'auto'       // Number of gene modules for Celda (auto or integer)

    // Differential expression
    run_diff_expression  = true         // Run differential expression analysis
    de_method            = 'wilcoxon'   // Method: 'wilcoxon', 't-test', 'logreg'
    de_n_genes           = 25           // Number of top genes to report per cluster
    de_min_fold_change   = 1.5          // Minimum fold change (linear scale)
    de_min_in_group_fraction = 0.25     // Minimum fraction of cells expressing in group
    de_max_out_group_fraction = 0.5     // Maximum fraction of cells expressing outside group

    // Cell type annotation
    run_annotation       = true         // Run cell type annotation
    annotation_method    = 'celltypist' // Method: 'celltypist' (pre-trained) or 'marker_scoring'
    celltypist_model     = 'Immune_All_Low.pkl'  // CellTypist model name
    marker_file          = 'default'    // Marker gene file for marker_scoring method

    // Gene set enrichment analysis
    run_gsea             = true         // Run gene set enrichment analysis
    gsea_gene_sets       = 'default'    // Gene set database ('default', 'GO', 'KEGG', or custom)
    gsea_n_top_genes     = 100          // Number of top marker genes to use for enrichment

    // Batch correction
    run_batch_correction = true         // Run batch effect detection and correction
    batch_key            = 'batch'      // Column in obs containing batch information
    batch_correction_method = 'harmony' // Method: 'harmony', 'combat', 'bbknn', 'scanorama'
    batch_effect_threshold = 0.3        // Threshold for applying correction (0-1 scale)

    // Cell cycle scoring
    run_cell_cycle       = true         // Run cell cycle phase scoring
    regress_cell_cycle   = false        // Regress out cell cycle effects from expression

    // Trajectory analysis
    run_trajectory       = true         // Run trajectory/pseudotime analysis
    trajectory_root      = 'auto'       // Root cell: 'auto', cluster ID, or cell barcode
    n_diffusion_comps    = 15           // Number of diffusion components

    // Cell-cell communication
    run_communication    = true         // Run cell-cell communication analysis
    communication_cell_type_key = 'auto' // Cell type annotation column to use
    communication_min_cells = 10        // Minimum cells per cell type
    communication_n_permutations = 100  // Number of permutations for significance testing

    // HTML report generation
    generate_report      = true         // Generate comprehensive HTML report
    report_title         = 'nf-scrnaseq Analysis Report'  // Report title

    // Publishing options
    publish_dir_mode   = 'copy'         // 'copy', 'symlink', 'move'

    // Resource limits
    max_memory         = '128.GB'
    max_cpus           = 16
    max_time           = '240.h'

    // Help
    help               = false
}

// Process configuration
process {
    // Default resources
    cpus   = { check_max( 1 * task.attempt, 'cpus' ) }
    memory = { check_max( 6.GB * task.attempt, 'memory' ) }
    time   = { check_max( 4.h * task.attempt, 'time' ) }

    errorStrategy = { task.exitStatus in [143,137,104,134,139] ? 'retry' : 'finish' }
    maxRetries    = 1
    maxErrors     = '-1'

    // Process-specific resources
    withLabel: process_low {
        cpus   = { check_max( 2, 'cpus' ) }
        memory = { check_max( 4.GB * task.attempt, 'memory' ) }
        time   = { check_max( 2.h * task.attempt, 'time' ) }
    }

    withLabel: process_medium {
        cpus   = { check_max( 4, 'cpus' ) }
        memory = { check_max( 16.GB * task.attempt, 'memory' ) }
        time   = { check_max( 8.h * task.attempt, 'time' ) }
    }

    withLabel: process_high {
        cpus   = { check_max( 8, 'cpus' ) }
        memory = { check_max( 32.GB * task.attempt, 'memory' ) }
        time   = { check_max( 16.h * task.attempt, 'time' ) }
    }
}

// Execution profiles
profiles {
    debug {
        cleanup = false
    }

    conda {
        conda.enabled          = true
        conda.useMamba         = false  // Disable mamba - uses more memory, can fail on WSL
        // Cache directory for conda environments - ensures reuse across runs
        // If environments still rebuild, try using an absolute path like:
        // conda.cacheDir = "/home/yourusername/.nextflow-conda-cache"
        conda.cacheDir         = "${System.getenv('HOME')}/.nextflow-conda-cache"
        docker.enabled         = false
        singularity.enabled    = false
        process.conda          = "${projectDir}/environment.yml"
    }

    docker {
        docker.enabled         = true
        docker.runOptions      = '-u $(id -u):$(id -g)'
        singularity.enabled    = false
        conda.enabled          = false
        process.container      = 'nf-scrnaseq:latest'
    }

    singularity {
        singularity.enabled    = true
        singularity.autoMounts = true
        docker.enabled         = false
        conda.enabled          = false
        process.container      = 'https://depot.galaxyproject.org/singularity/scanpy:1.9.3--pyhdfd78af_0'
    }

    test {
        params.input           = "${projectDir}/test_data/10x_sample"
        params.max_memory      = '6.GB'
        params.max_cpus        = 2
        params.max_time        = '1.h'

        // Adjusted QC parameters for realistic test data (200 cells, 105 genes)
        // Test data uses real PBMC gene markers for proper annotation testing
        params.min_genes       = 20
        params.max_genes       = 105
        params.min_cells       = 1
        params.max_pct_mt      = 25

        // Enable doublet detection for 200-cell test dataset
        params.run_doublet_detection = true
        params.run_scrublet    = true

        // Adjusted HVG and dim reduction parameters for test dataset
        params.n_top_genes     = 80           // Most variable genes from 105 total
        params.n_pcs           = 20           // Reasonable PCs for 200 cells
        params.n_neighbors     = 10           // Neighbors for 200 cells
        params.tsne_perplexity = 15           // Perplexity for 200 cells

        // Use marker scoring method for annotation (more reliable for small datasets)
        params.annotation_method = 'marker_scoring'
    }
}

// Capture exit codes from upstream processes when piping
process.shell = ['/bin/bash', '-euo', 'pipefail']

// Export these variables to prevent local Python/R libraries from conflicting
env {
    PYTHONNOUSERSITE = 1
    R_PROFILE_USER   = "/.Rprofile"
    R_ENVIRON_USER   = "/.Renviron"
}

// Manifest
manifest {
    name            = 'nf-scrnaseq'
    author          = 'salzcamino'
    homePage        = 'https://github.com/salzcamino/nf-scrnaseq'
    description     = 'Single-cell RNA-seq analysis pipeline using Nextflow'
    mainScript      = 'main.nf'
    nextflowVersion = '!>=22.10.0'
    version         = '0.1.0'
}

// Function to ensure that resource requirements don't go beyond maximum limit
def check_max(obj, type) {
    if (type == 'memory') {
        try {
            if (obj.compareTo(params.max_memory as nextflow.util.MemoryUnit) == 1)
                return params.max_memory as nextflow.util.MemoryUnit
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max memory '${params.max_memory}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'time') {
        try {
            if (obj.compareTo(params.max_time as nextflow.util.Duration) == 1)
                return params.max_time as nextflow.util.Duration
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max time '${params.max_time}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'cpus') {
        try {
            return Math.min( obj, params.max_cpus as int )
        } catch (all) {
            println "   ### ERROR ###   Max cpus '${params.max_cpus}' is not valid! Using default value: $obj"
            return obj
        }
    }
}
